Redis 中查找特定的key：两种方法 keys、scan
Key的缺点：
1.没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，当你看到满屏的字符串刷的没有尽头时，你就知道难受了。
2.keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续...

Scan 可以解决上述的缺点：
1.复杂度虽然也是 O(n)，但是它是通过游标分布进行的，不会阻塞线程;
2.提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是一个 hint，返回的结果可多可少;
3.同 keys 一样，它也提供模式匹配功能;
4.服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;
5.返回的结果可能会有重复，需要客户端去重复，这点非常重要;
6.遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;
7.单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零;...

Scan 遍历方法：
普通加法和高位进位加法：优点考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。

渐进式rehash
Java 的 HashMap 在扩容时会一次性将旧数组下挂接的元素全部转移到新数组下面。如果 HashMap 中元素特别多，线程就会出现卡顿现象。Redis 为了解决这个问题，它采用渐进式 rehash。
它会同时保留旧数组和新数组，然后在定时任务中以及后续对 hash 的指令操作中渐渐地将旧数组中挂接的元素迁移到新数组上。这意味着要操作处于 rehash 中的字典，需要同时访问新旧两个数组结构。如果在旧数组下面找不到元素，还需要去新数组下面去寻找。...